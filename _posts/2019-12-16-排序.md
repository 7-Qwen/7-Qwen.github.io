# 10个排序的时间复杂度的情况

![](C:\Users\JAVASM\Desktop\assets_-Lm9JtwbhXVOfXyecToy_-Lm9KQIJAMvCgJQzErQS_-Lm9KSPi7v-ygMtlI6Zr_sort.png)

## 关于时间复杂度：

1.平方阶 (O(n2)) 排序

​	各类简单排序：直接插入、直接选择和冒泡排序。

2.线性对数阶 (O(nlog2n)) 排序

 	快速排序、堆排序和归并排序；

3.O(n1+§)) 排序，§ 是介于 0 和 1 之间的常数。

 	希尔排序

4.线性阶 (O(n)) 排序

 	基数排序，此外还有桶、箱排序。

## 关于稳定性：

1. 稳定的排序算法：冒泡排序、插入排序、归并排序和基数排序。
2. 不是稳定的排序算法：选择排序、快速排序、希尔排序、堆排序。

## 名词解释：

1. **n**：数据规模
2. **k**：“桶”的个数
3. **In-place**：占用常数内存，不占用额外内存
4. **Out-place**：占用额外内存
5. **稳定性**：排序后 2 个相等键值的顺序和排序之前它们的顺序相同



# **一、冒泡排序**

冒泡排序（Bubble Sort）也是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。

![](C:\Users\JAVASM\Desktop\849589-20171015223238449-2146169197.gif)

## 1.**关键算法**

1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。
2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步    做完后，最后的元素会是最大的数。
3. 针对所有的元素重复以上的步骤，除了最后一个。
4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。

# **二、选择排序**

选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。

![](C:\Users\JAVASM\Desktop\849589-20171015224719590-1433219824.gif)

1.关键算法

